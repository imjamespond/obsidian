### 3.1. 线性回归[¶](https://zh-v2.d2l.ai/chapter_linear-networks/linear-regression.html#sec-linear-regression "Permalink to this heading")
![[Pasted image 20231018143450.png|800]]
[(3.1.1)](https://zh-v2.d2l.ai/chapter_linear-networks/linear-regression.html#equation-eq-price-area)中的$w_{\mathrm{area}}$和$w_{\mathrm{age}}$
称为*权重*（weight），权重决定了每个特征对我们预测值的影响。
==$b$称为*偏置*（bias）==、*偏移量*（offset）或*截距*（intercept）。
==**偏置是指当所有特征都取值为0时，预测值应该为多少。**==
即使现实中不会有任何房子的面积是0或房龄正好是0年，我们仍然需要偏置项。
如果没有偏置项，我们模型的表达能力将受到限制。
严格来说， :eqref:`eq_price-area`是输入特征的一个
*仿射变换*（affine transformation）。
仿射变换的特点是通过加权和对特征进行*线性变换*（linear transformation），
并通过偏置项来进行*平移*（translation）。


而在机器学习领域，我们通常使用的是高维数据集，建模时采用线性代数表示法会比较方便。
当我们的输入包含$d$个特征时，我们将预测结果$\hat{y}$
（通常使用“尖角”符号表示$y$的估计值）表示为：
$$\hat{y} = w_1  x_1 + ... + w_d  x_d + b.$$

将所有==特征放到向量==$\mathbf{x} \in \mathbb{R}^d$中，
并将所有==权重放到向量==$\mathbf{w} \in \mathbb{R}^d$中，
我们可以用点积形式来简洁地表达模型：
$$\hat{y} = \mathbf{w}^\top \mathbf{x} + b.$$

向量$\mathbf{x}$对应于==单个数据**样本**==的特征。
用符号表示的==**矩阵**==$\mathbf{X} \in \mathbb{R}^{n \times d}$
可以很方便地引用我们整个==数据集的$n$个样本==。
其中，$\mathbf{X}$的==每一**行**是一个**样本**==，==每一**列**是一种**特征**。==

对于特征集合$\mathbf{X}$，预测值$\hat{\mathbf{y}} \in \mathbb{R}^n$
可以通过矩阵-向量乘法表示为：
$${\hat{\mathbf{y}}} = \mathbf{X} \mathbf{w} + b$$

这个过程中的求和将使用==广播机制==
（广播机制在 :numref:`subsec_broadcasting`中有详细介绍）。
给定==训练数据==特征$\mathbf{X}$和对应的==已知标签$\mathbf{y}$==，
==线性回归的**目标**是==找到==**一组权重**向量$\mathbf{w}$和**偏置**$b$：==
当给定从$\mathbf{X}$的同分布中取样的新样本特征时，
这组==权重向量==和==偏置==能够使得新样本预测标签的误差尽可能小。

虽然我们相信给定$\mathbf{x}$预测$y$的最佳模型会是线性的，
但我们很难找到一个有$n$个样本的真实数据集，其中对于所有的$1 \leq i \leq n$，$y^{(i)}$完全等于$\mathbf{w}^\top \mathbf{x}^{(i)}+b$。
无论我们使用什么手段来观察特征$\mathbf{X}$和标签$\mathbf{y}$，
都可能会出现少量的观测误差。
因此，即使确信特征与标签的潜在关系是线性的，
我们也会==加入一个噪声项==来考虑观测误差带来的影响。

在开始寻找最好的*模型参数*（model parameters）$\mathbf{w}$和$b$之前，
我们还需要两个东西：
（1）一种模型质量的==度量方式==；
（2）一种能够更新模型以提高模型预测质量的==方法==。

### 损失函数

在我们开始考虑如何用模型*拟合*（fit）数据之前，我们需要确定一个==拟合程度的度量==。
*==损失函数==*（loss function）==能够量化目标的*实际*值与*预测*值之间的差距==。
通常我们会选择==非负数作为损失==，且数值越小表示损失越小，==完美预测时的损失为0==。
回归问题中最常用的损失函数是平方误差函数。
当==样本$i$的预测值==为$\hat{y}^{(i)}$，其相应的==真实标签为==$y^{(i)}$时，
平方误差可以定义为以下公式：

$$l^{(i)}(\mathbf{w}, b) = \frac{1}{2} \left(\hat{y}^{(i)} - y^{(i)}\right)^2.$$
:eqlabel:`eq_mse`

常数$\frac{1}{2}$不会带来本质的差别，但这样在形式上稍微简单一些
（因为当我们对损失函数求导后常数系数为1）。
由于训练数据集并不受我们控制，所以经验误差只是关于模型参数的函数。
为了进一步说明，来看下面的例子。
我们为一维情况下的回归问题绘制图像，如 :numref:`fig_fit_linreg`所示。
![[Pasted image 20231020140636.png|200]]
:label:`fig_fit_linreg`

由于平方误差函数中的二次方项，
估计值$\hat{y}^{(i)}$和观测值$y^{(i)}$之间较大的差异将导致更大的损失。
为了度量模型在整个数据集上的质量，我们需计算在训练集$n$个样本上的==损失均值==（也等价于求和）。

$$L(\mathbf{w}, b) =\frac{1}{n}\sum_{i=1}^n l^{(i)}(\mathbf{w}, b) =\frac{1}{n} \sum_{i=1}^n \frac{1}{2}\left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right)^2.$$

在训练模型时，我们希望==寻找一组参数==（$\mathbf{w}^*, b^*$），
这组参数能==最小化在所有训练样本上的**总损失**==。如下式：

$$\mathbf{w}^*, b^* = \operatorname*{argmin}_{\mathbf{w}, b}\  L(\mathbf{w}, b).$$

### 解析解

线性回归刚好是一个很简单的优化问题。
与我们将在本书中所讲到的其他大部分模型不同，线性回归的解可以用一个公式简单地表达出来，
这类解叫作解析解（analytical solution）。
首先，我们将==偏置$b$合并到参数$\mathbf{w}$中==，合并方法是在包含所有参数的==矩阵中附加一列==。
我们的预测问题是最小化$\|\mathbf{y} - \mathbf{X}\mathbf{w}\|^2$。
这在损失平面上只有一个临界点，这个临界点对应于整个区域的损失极小点。
==将**损失***关于*$\mathbf{w}$的**导数**设为0，得到解析解==：

$$\mathbf{w}^* = (\mathbf X^\top \mathbf X)^{-1}\mathbf X^\top \mathbf{y}.$$

像线性回归这样的简单问题存在解析解，但并不是所有的问题都存在解析解。
解析解可以进行很好的数学分析，但解析解对问题的限制很严格，导致它无法广泛应用在深度学习里。

### 随机梯度下降

即使在我们无法得到解析解的情况下，我们仍然可以有效地训练模型。
在许多任务上，那些难以优化的模型效果要更好。
因此，弄清楚如何训练这些难以优化的模型是非常重要的。

本书中我们用到一种名为*梯度下降*（gradient descent）的方法，
这种方法几乎可以优化所有深度学习模型。
它通过不断地在损失函数递减的方向上更新参数来降低误差。

梯度下降最简单的用法是计算损失函数（数据集中==所有样本的损失均值==）
关于模型参数的导数（在这里也可以称为梯度）。
但实际中的执行可能会<font color="#ff0000">非常慢</font>：因为在每一次更新参数之前，我们==必须**遍历**<span style="background:#ff4d4f">整个</span>**数据集**==。
因此，我们通常会在每次需要计算更新的时候==随机抽取一**小批**样本==，
这种变体叫做==*小批量随机梯度下降*==（minibatch stochastic gradient descent）。

==在每次迭代中==，我们==首先随机抽样一个小批量==$\mathcal{B}$，
它是由固定数量的训练样本组成的。
然后，我们计算==小批量的**平均损失***关于***模型参数**的<font color="#ff0000" size=5>导数</font>==（也可以称为梯度）。
最后，我们将==梯度乘以==一个预先确定的==正数==$\eta$，并从当前参数的值中减掉。

我们用下面的数学公式来表示这一更新过程（$\partial$表示==偏导数==）：

$$(\mathbf{w},b) \leftarrow (\mathbf{w},b) - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{(\mathbf{w},b)} l^{(i)}(\mathbf{w},b).$$

总结一下，算法的步骤如下：
（1）初始化模型参数的值，如==随机初始化==；
（2）从数据集中随机抽取小批量样本且==在负梯度的方向上更新参数==，并不断迭代这一步骤。
对于平方损失和仿射变换，我们可以明确地写成如下形式:

$$\begin{aligned} \mathbf{w} &\leftarrow \mathbf{w} -   \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{\mathbf{w}} l^{(i)}(\mathbf{w}, b) = \mathbf{w} - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \mathbf{x}^{(i)} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right),\\ b &\leftarrow b -  \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_b l^{(i)}(\mathbf{w}, b)  = b - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right). \end{aligned}$$
:eqlabel:`eq_linreg_batch_update`

公式 :eqref:`eq_linreg_batch_update`中的$\mathbf{w}$和$\mathbf{x}$都是向量。
在这里，更优雅的向量表示法比系数表示法（如$w_1, w_2, \ldots, w_d$）更具可读性。
$|\mathcal{B}|$表示每个小批量中的==样本数==，这也称为==*批量大小*（batch size）==。
==$\eta$表示*学习率*==（learning rate）。
==批量大小==和==学习率==的值通常是==手动预先指定==，而不是通过模型训练得到的。
这些可以调整但不在训练过程中更新的参数称为*超参数*（hyperparameter）。
*调参*（hyperparameter tuning）是选择超参数的过程。
超参数通常是我们根据训练迭代结果来调整的，
而训练迭代结果是在独立的*验证数据集*（validation dataset）上评估得到的。

在训练了预先确定的若干迭代次数后（或者直到满足某些其他停止条件后），
我们记录下模型参数的估计值，表示为$\hat{\mathbf{w}}, \hat{b}$。
但是，即使我们的函数确实是线性的且无噪声，这些估计值也不会使损失函数真正地达到最小值。
因为**算法**会使得损失向最小值**缓慢收敛**，但却不能在==有限的步数内==非常精确地达到最小值。

线性回归恰好是一个在整个域中只有一个最小值的学习问题。
但是对像深度神经网络这样复杂的模型来说，损失平面上通常包含==多个最小值==。
深度学习实践者很少会去花费大力气寻找这样一组参数，使得在*训练集*上的损失达到最小。
事实上，==更难做到==的是找到==一组参数==，这组参数能够在我们从未见过的数据上实现较低的损失，
这一挑战被称为==*泛化*==（generalization）。

### 用模型进行预测

给定“已学习”的线性回归模型$\hat{\mathbf{w}}^\top \mathbf{x} + \hat{b}$，
现在我们可以通过房屋面积$x_1$和房龄$x_2$来估计一个（未包含在训练数据中的）新房屋价格。
给定特征估计目标的过程通常称为*预测*（prediction）或*推断*（inference）。

本书将尝试坚持使用*预测*这个词。
虽然*推断*这个词已经成为深度学习的标准术语，但其实*推断*这个词有些用词不当。
在统计学中，*推断*更多地表示基于数据集估计参数。
当深度学习从业者与统计学家交谈时，术语的误用经常导致一些误解。

## 矢量化加速

在训练我们的模型时，我们经常希望能够同时处理整个小批量的样本。
为了实现这一点，需要(**我们对计算进行矢量化，
从而利用线性代数库，而不是在Python中编写开销高昂的for循环**)。

